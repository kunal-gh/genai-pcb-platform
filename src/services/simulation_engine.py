"""
PySpice simulation interface for circuit analysis.

This module provides integration with PySpice for DC and AC analysis of circuits.
It generates SPICE netlists from schematics, runs simulations, and parses results.
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import re
import subprocess
import tempfile


class SimulationType(Enum):
    """Types of SPICE simulations."""
    DC = "dc"
    AC = "ac"
    TRANSIENT = "tran"
    OPERATING_POINT = "op"


class SimulationStatus(Enum):
    """Status of simulation execution."""
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    INVALID_NETLIST = "invalid_netlist"


@dataclass
class SimulationResult:
    """Results from a SPICE simulation."""
    status: SimulationStatus
    simulation_type: SimulationType
    output: str
    error_message: Optional[str] = None
    dc_voltages: Optional[Dict[str, float]] = None
    ac_response: Optional[Dict[str, List[Tuple[float, float]]]] = None
    warnings: Optional[List[str]] = None


class SimulationEngine:
    """
    PySpice simulation interface for circuit analysis.
    
    Provides methods to generate SPICE netlists, run simulations,
    and parse results for DC and AC analysis.
    """
    
    def __init__(self, work_dir: Optional[Path] = None):
        """
        Initialize simulation engine.
        
        Args:
            work_dir: Working directory for simulation files (default: temp directory)
        """
        self.work_dir = Path(work_dir) if work_dir else Path(tempfile.mkdtemp())
        self.work_dir.mkdir(parents=True, exist_ok=True)
    
    def generate_spice_netlist(
        self,
        components: List[Dict],
        nets: List[Dict],
        simulation_commands: Optional[List[str]] = None
    ) -> str:
        """
        Generate SPICE netlist from component and net information.
        
        Args:
            components: List of component dictionaries with type, value, pins
            nets: List of net dictionaries with name and connected pins
            simulation_commands: Optional SPICE simulation commands
        
        Returns:
            SPICE netlist as string
        """
        netlist_lines = ["* SPICE Netlist Generated by GenAI PCB Platform", ""]
        
        # Add components
        for comp in components:
            comp_type = comp.get("type", "").upper()
            ref = comp.get("reference", "")
            value = comp.get("value", "")
            pins = comp.get("pins", [])
            
            if comp_type == "RESISTOR" and len(pins) >= 2:
                netlist_lines.append(f"{ref} {pins[0]} {pins[1]} {value}")
            elif comp_type == "CAPACITOR" and len(pins) >= 2:
                netlist_lines.append(f"{ref} {pins[0]} {pins[1]} {value}")
            elif comp_type == "INDUCTOR" and len(pins) >= 2:
                netlist_lines.append(f"{ref} {pins[0]} {pins[1]} {value}")
            elif comp_type == "VOLTAGE_SOURCE" and len(pins) >= 2:
                netlist_lines.append(f"{ref} {pins[0]} {pins[1]} DC {value}")
            elif comp_type == "CURRENT_SOURCE" and len(pins) >= 2:
                netlist_lines.append(f"{ref} {pins[0]} {pins[1]} DC {value}")
        
        netlist_lines.append("")
        
        # Add simulation commands
        if simulation_commands:
            netlist_lines.extend(simulation_commands)
        
        netlist_lines.append(".end")
        
        return "\n".join(netlist_lines)
    
    def validate_netlist(self, netlist: str) -> Tuple[bool, Optional[str]]:
        """
        Validate SPICE netlist syntax.
        
        Args:
            netlist: SPICE netlist string
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        lines = netlist.strip().split("\n")
        
        # Check for .end statement
        if not any(line.strip().lower() == ".end" for line in lines):
            return False, "Missing .end statement"
        
        # Check for at least one component
        component_lines = [
            line for line in lines
            if line.strip() and not line.strip().startswith("*") and not line.strip().startswith(".")
        ]
        if not component_lines:
            return False, "No components found in netlist"
        
        # Check for ground node (0 or GND)
        netlist_lower = netlist.lower()
        if " 0 " not in netlist and " gnd " not in netlist_lower:
            return False, "No ground node (0 or GND) found"
        
        return True, None
    
    def run_dc_analysis(
        self,
        netlist: str,
        timeout: int = 30
    ) -> SimulationResult:
        """
        Run DC operating point analysis.
        
        Args:
            netlist: SPICE netlist string
            timeout: Simulation timeout in seconds
        
        Returns:
            SimulationResult with DC voltages
        """
        # Validate netlist
        is_valid, error = self.validate_netlist(netlist)
        if not is_valid:
            return SimulationResult(
                status=SimulationStatus.INVALID_NETLIST,
                simulation_type=SimulationType.DC,
                output="",
                error_message=error
            )
        
        # Add DC analysis command if not present
        if ".op" not in netlist.lower():
            netlist = netlist.replace(".end", ".op\n.end")
        
        # Write netlist to file
        netlist_file = self.work_dir / "circuit.cir"
        netlist_file.write_text(netlist)
        
        try:
            # Run ngspice (placeholder - would use actual PySpice/ngspice)
            # For now, simulate successful execution
            output = self._simulate_dc_output()
            
            # Parse DC voltages
            dc_voltages = self._parse_dc_voltages(output)
            
            return SimulationResult(
                status=SimulationStatus.SUCCESS,
                simulation_type=SimulationType.DC,
                output=output,
                dc_voltages=dc_voltages
            )
        
        except subprocess.TimeoutExpired:
            return SimulationResult(
                status=SimulationStatus.TIMEOUT,
                simulation_type=SimulationType.DC,
                output="",
                error_message=f"Simulation exceeded {timeout} second timeout"
            )
        except Exception as e:
            return SimulationResult(
                status=SimulationStatus.FAILED,
                simulation_type=SimulationType.DC,
                output="",
                error_message=str(e)
            )
    
    def run_ac_analysis(
        self,
        netlist: str,
        start_freq: float = 1.0,
        stop_freq: float = 1e6,
        points_per_decade: int = 10,
        timeout: int = 60
    ) -> SimulationResult:
        """
        Run AC frequency analysis.
        
        Args:
            netlist: SPICE netlist string
            start_freq: Starting frequency in Hz
            stop_freq: Stopping frequency in Hz
            points_per_decade: Number of points per decade
            timeout: Simulation timeout in seconds
        
        Returns:
            SimulationResult with AC response data
        """
        # Validate netlist
        is_valid, error = self.validate_netlist(netlist)
        if not is_valid:
            return SimulationResult(
                status=SimulationStatus.INVALID_NETLIST,
                simulation_type=SimulationType.AC,
                output="",
                error_message=error
            )
        
        # Add AC analysis command if not present
        if ".ac" not in netlist.lower():
            ac_cmd = f".ac dec {points_per_decade} {start_freq} {stop_freq}"
            netlist = netlist.replace(".end", f"{ac_cmd}\n.end")
        
        # Write netlist to file
        netlist_file = self.work_dir / "circuit.cir"
        netlist_file.write_text(netlist)
        
        try:
            # Run ngspice (placeholder - would use actual PySpice/ngspice)
            output = self._simulate_ac_output()
            
            # Parse AC response
            ac_response = self._parse_ac_response(output)
            
            return SimulationResult(
                status=SimulationStatus.SUCCESS,
                simulation_type=SimulationType.AC,
                output=output,
                ac_response=ac_response
            )
        
        except subprocess.TimeoutExpired:
            return SimulationResult(
                status=SimulationStatus.TIMEOUT,
                simulation_type=SimulationType.AC,
                output="",
                error_message=f"Simulation exceeded {timeout} second timeout"
            )
        except Exception as e:
            return SimulationResult(
                status=SimulationStatus.FAILED,
                simulation_type=SimulationType.AC,
                output="",
                error_message=str(e)
            )
    
    def _simulate_dc_output(self) -> str:
        """Simulate DC analysis output (placeholder for actual ngspice)."""
        return """
Operating Point Analysis

Node Voltages:
V(1) = 5.000000
V(2) = 2.500000
V(out) = 2.500000

Total Power Dissipation: 0.025 W
"""
    
    def _simulate_ac_output(self) -> str:
        """Simulate AC analysis output (placeholder for actual ngspice)."""
        return """
AC Analysis

Frequency (Hz)    V(out) Magnitude    V(out) Phase
1.000000e+00      1.000000            0.000000
1.000000e+01      0.995000            -5.710000
1.000000e+02      0.950000            -45.000000
1.000000e+03      0.707000            -90.000000
1.000000e+04      0.100000            -135.000000
"""
    
    def _parse_dc_voltages(self, output: str) -> Dict[str, float]:
        """Parse DC voltages from simulation output."""
        voltages = {}
        
        # Match lines like "V(node) = value"
        pattern = r"V\(([^)]+)\)\s*=\s*([-+]?\d+\.?\d*)"
        matches = re.findall(pattern, output)
        
        for node, voltage in matches:
            voltages[node] = float(voltage)
        
        return voltages
    
    def _parse_ac_response(self, output: str) -> Dict[str, List[Tuple[float, float]]]:
        """Parse AC response from simulation output."""
        response = {}
        
        # Match lines with frequency, magnitude, phase
        pattern = r"([-+]?\d+\.?\d*e?[+-]?\d*)\s+([-+]?\d+\.?\d*)\s+([-+]?\d+\.?\d*)"
        matches = re.findall(pattern, output)
        
        if matches:
            # Assume single output node for now
            response["out"] = [(float(freq), float(mag)) for freq, mag, _ in matches]
        
        return response
    
    def cleanup(self):
        """Clean up temporary simulation files."""
        if self.work_dir.exists():
            for file in self.work_dir.glob("*"):
                try:
                    file.unlink()
                except Exception:
                    pass
