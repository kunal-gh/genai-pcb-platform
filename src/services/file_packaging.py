"""
File Packaging Service

Handles comprehensive file packaging, archiving, and multi-format export
for PCB design projects.
"""

import os
import zipfile
import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass, asdict


@dataclass
class PackageManifest:
    """Manifest describing package contents"""
    project_name: str
    created_at: str
    version: str
    description: str
    files: List[Dict[str, str]]
    metadata: Dict[str, Any]


class FilePackager:
    """Handles design file packaging and archiving"""
    
    def __init__(self, output_dir: str = "generated_designs"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
    
    def create_package(
        self,
        design_id: str,
        project_name: str,
        files: List[Dict[str, str]],
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Create a comprehensive design package with all files
        
        Args:
            design_id: Unique design identifier
            project_name: Human-readable project name
            files: List of file dictionaries with 'path', 'type', 'name'
            metadata: Additional project metadata
            
        Returns:
            Path to created package file
        """
        # Create package directory
        package_name = self._sanitize_filename(f"{project_name}_{design_id}")
        package_dir = self.output_dir / package_name
        package_dir.mkdir(exist_ok=True)
        
        # Organize files by type
        organized_files = self._organize_files(files, package_dir)
        
        # Create manifest
        manifest = PackageManifest(
            project_name=project_name,
            created_at=datetime.utcnow().isoformat(),
            version="1.0",
            description=f"PCB design package for {project_name}",
            files=organized_files,
            metadata=metadata or {}
        )
        
        # Write manifest
        manifest_path = package_dir / "manifest.json"
        with open(manifest_path, 'w') as f:
            json.dump(asdict(manifest), f, indent=2)
        
        # Create README
        self._create_readme(package_dir, project_name, organized_files)
        
        # Create ZIP archive
        zip_path = self.output_dir / f"{package_name}.zip"
        self._create_zip(package_dir, zip_path)
        
        return str(zip_path)
    
    def _organize_files(
        self,
        files: List[Dict[str, str]],
        package_dir: Path
    ) -> List[Dict[str, str]]:
        """Organize files into categorized subdirectories"""
        organized = []
        
        # Define file categories and their directories
        categories = {
            'schematic': 'schematics',
            'pcb': 'pcb',
            'gerber': 'manufacturing/gerbers',
            'drill': 'manufacturing/drill',
            'bom': 'bom',
            'netlist': 'netlists',
            'simulation': 'simulation',
            'documentation': 'docs',
            'step': '3d_models',
        }
        
        for file_info in files:
            file_path = Path(file_info['path'])
            file_type = file_info.get('type', 'other')
            file_name = file_info.get('name', file_path.name)
            
            # Determine target directory
            target_subdir = categories.get(file_type, 'other')
            target_dir = package_dir / target_subdir
            target_dir.mkdir(parents=True, exist_ok=True)
            
            # Copy file to target directory
            target_path = target_dir / file_name
            if file_path.exists():
                import shutil
                shutil.copy2(file_path, target_path)
                
                organized.append({
                    'name': file_name,
                    'type': file_type,
                    'path': str(Path(target_subdir) / file_name),
                    'size': target_path.stat().st_size
                })
        
        return organized
    
    def _create_readme(
        self,
        package_dir: Path,
        project_name: str,
        files: List[Dict[str, str]]
    ):
        """Create README file with package information"""
        readme_path = package_dir / "README.md"
        
        # Group files by type
        files_by_type: Dict[str, List[Dict[str, str]]] = {}
        for file_info in files:
            file_type = file_info['type']
            if file_type not in files_by_type:
                files_by_type[file_type] = []
            files_by_type[file_type].append(file_info)
        
        # Generate README content
        content = f"""# {project_name}

PCB Design Package generated by GenAI PCB Design Platform

## Package Contents

"""
        
        # Add file listings by category
        category_names = {
            'schematic': 'Schematic Files',
            'pcb': 'PCB Layout Files',
            'gerber': 'Gerber Files (Manufacturing)',
            'drill': 'Drill Files',
            'bom': 'Bill of Materials',
            'netlist': 'Netlist Files',
            'simulation': 'Simulation Results',
            'documentation': 'Documentation',
            'step': '3D Models',
        }
        
        for file_type, type_files in sorted(files_by_type.items()):
            category_name = category_names.get(file_type, file_type.title())
            content += f"### {category_name}\n\n"
            for file_info in type_files:
                size_kb = file_info['size'] / 1024
                content += f"- `{file_info['path']}` ({size_kb:.1f} KB)\n"
            content += "\n"
        
        content += """## Usage

### Opening in KiCad
1. Open KiCad
2. File -> Open Project
3. Navigate to the `schematics/` or `pcb/` directory
4. Open the `.kicad_pro` file

### Manufacturing
The `manufacturing/` directory contains all files needed for PCB fabrication:
- Gerber files in `manufacturing/gerbers/`
- Drill files in `manufacturing/drill/`
- Bill of Materials in `bom/`

### 3D Visualization
STEP files in `3d_models/` can be opened in:
- FreeCAD
- Fusion 360
- SolidWorks
- Any CAD software supporting STEP format

## Support

For issues or questions, please refer to the GenAI PCB Design Platform documentation.
"""
        
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _create_zip(self, source_dir: Path, zip_path: Path):
        """Create ZIP archive of package directory"""
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file_path in source_dir.rglob('*'):
                if file_path.is_file():
                    arcname = file_path.relative_to(source_dir.parent)
                    zipf.write(file_path, arcname)
    
    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for filesystem compatibility"""
        # Remove or replace invalid characters
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            filename = filename.replace(char, '_')
        return filename
    
    def export_to_format(
        self,
        source_files: List[str],
        target_format: str,
        output_path: str
    ) -> str:
        """
        Export design to different EDA tool formats
        
        Args:
            source_files: List of source file paths
            target_format: Target format (altium, eagle, orcad, ipc2581, odbpp)
            output_path: Output file path
            
        Returns:
            Path to exported file
        """
        # Format conversion mappings
        converters = {
            'altium': self._export_to_altium,
            'eagle': self._export_to_eagle,
            'orcad': self._export_to_orcad,
            'ipc2581': self._export_to_ipc2581,
            'odbpp': self._export_to_odbpp,
        }
        
        if target_format not in converters:
            raise ValueError(f"Unsupported format: {target_format}")
        
        return converters[target_format](source_files, output_path)
    
    def _export_to_altium(self, source_files: List[str], output_path: str) -> str:
        """Export to Altium format"""
        # Placeholder for Altium export
        # In production, would use KiCad conversion tools or libraries
        output_file = Path(output_path) / "design.PrjPcb"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Create placeholder Altium project file
        with open(output_file, 'w') as f:
            f.write("[Design]\n")
            f.write("Version=1.0\n")
            f.write(f"Timestamp={datetime.utcnow().isoformat()}\n")
        
        return str(output_file)
    
    def _export_to_eagle(self, source_files: List[str], output_path: str) -> str:
        """Export to Eagle format"""
        output_file = Path(output_path) / "design.brd"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Create placeholder Eagle board file
        with open(output_file, 'w') as f:
            f.write('<?xml version="1.0" encoding="utf-8"?>\n')
            f.write('<!DOCTYPE eagle SYSTEM "eagle.dtd">\n')
            f.write('<eagle version="9.0">\n')
            f.write('  <drawing>\n')
            f.write('    <board>\n')
            f.write('    </board>\n')
            f.write('  </drawing>\n')
            f.write('</eagle>\n')
        
        return str(output_file)
    
    def _export_to_orcad(self, source_files: List[str], output_path: str) -> str:
        """Export to OrCAD format"""
        output_file = Path(output_path) / "design.dsn"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Create placeholder OrCAD design file
        with open(output_file, 'w') as f:
            f.write("(PCB design\n")
            f.write("  (parser\n")
            f.write("    (host_cad OrCAD)\n")
            f.write("  )\n")
            f.write(")\n")
        
        return str(output_file)
    
    def _export_to_ipc2581(self, source_files: List[str], output_path: str) -> str:
        """Export to IPC-2581 format"""
        output_file = Path(output_path) / "design.xml"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Create placeholder IPC-2581 file
        with open(output_file, 'w') as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write('<IPC-2581 xmlns="http://webstds.ipc.org/2581" version="C">\n')
            f.write('  <Content>\n')
            f.write('    <FunctionMode>DESIGN</FunctionMode>\n')
            f.write('  </Content>\n')
            f.write('</IPC-2581>\n')
        
        return str(output_file)
    
    def _export_to_odbpp(self, source_files: List[str], output_path: str) -> str:
        """Export to ODB++ format"""
        output_dir = Path(output_path) / "design.odb"
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Create ODB++ directory structure
        (output_dir / "steps").mkdir(exist_ok=True)
        (output_dir / "fonts").mkdir(exist_ok=True)
        (output_dir / "symbols").mkdir(exist_ok=True)
        
        # Create matrix file
        matrix_file = output_dir / "matrix" / "matrix"
        matrix_file.parent.mkdir(exist_ok=True)
        with open(matrix_file, 'w') as f:
            f.write("# ODB++ Matrix File\n")
            f.write(f"TIMESTAMP={datetime.utcnow().isoformat()}\n")
        
        return str(output_dir)
    
    def add_documentation(
        self,
        package_dir: str,
        design_notes: str,
        specifications: Dict[str, Any]
    ):
        """Add project documentation to package"""
        docs_dir = Path(package_dir) / "docs"
        docs_dir.mkdir(exist_ok=True)
        
        # Create design notes file
        notes_file = docs_dir / "design_notes.md"
        with open(notes_file, 'w') as f:
            f.write("# Design Notes\n\n")
            f.write(design_notes)
        
        # Create specifications file
        specs_file = docs_dir / "specifications.json"
        with open(specs_file, 'w') as f:
            json.dump(specifications, f, indent=2)
